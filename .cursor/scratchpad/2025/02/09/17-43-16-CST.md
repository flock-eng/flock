---
title: "Scratchpad: Authentication System Implementation Guide"
created: "2025-02-09T17:43:16Z"
updated: "2025-02-09T17:43:16Z"
tags: [auth, microservices, temporal, workflow, design]
id: "scratchpad-20250209-174316"
status: "draft"
---

# Context & Objectives

We need to implement a new authentication system with the following requirements:
- User registration flow using Temporal workflows
- Two microservices: auth and profile services
- PostgreSQL databases for each service
- ScyllaDB-backed Temporal service
- Proper translation between DB objects and Protobuf messages

# Brainstorming & Exploration

## Service Architecture
- Auth Service: Handles user authentication and manages credentials
- Profile Service: Manages user profile information
- Temporal Workflow: Coordinates the registration process across services
- Each service needs its own database to maintain service autonomy

## Data Flow
1. User initiates registration
2. Temporal workflow starts
3. Create user record in auth service
4. Create profile record in profile service
5. Handle compensation if any step fails

# Prototypes & Experiments

## Service Creation
```bash
# Create the auth service using the template
./scripts/create_microservice.sh flock-auth-service

# Create the profile service using the template
./scripts/create_microservice.sh flock-profile-service
```

## Directory Structures

### Auth Service
```
flock-auth-service/
├── cmd/
│   └── main.go
├── internal/
│   ├── domain/
│   │   ├── user.go          # User domain model
│   │   └── token.go         # JWT token model
│   │   └── repository/
│   │   └── postgres/
│   │       └── user.go      # User repository implementation
│   │   └── service/
│   │       └── auth.go          # Auth business logic
│   │   └── temporal/
│   │       ├── workflows/
│   │       │   └── registration.go
│   │       └── activities/
│   │           └── user.go
│   │   └── proto/                   # Generated protobuf code
│   │       └── auth/
│   │           └── v1/
│   │               └── auth.pb.go
│   │
```

### Profile Service
```
flock-profile-service/
├── cmd/
│   └── main.go
├── internal/
│   ├── domain/
│   │   └── profile.go       # Profile domain model
│   │   └── repository/
│   │   └── postgres/
│   │       └── profile.go   # Profile repository implementation
│   │   └── service/
│   │       └── profile.go       # Profile business logic
│   │   └── temporal/
│   │       └── activities/
│   │           └── profile.go
│   │   └── proto/                   # Generated protobuf code
│   │       └── profile/
│   │           └── v1/
│   │               └── profile.pb.go
│   │
```

## Database Schema Prototypes

### Auth Service Schema
```sql
-- auth_service.sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE auth_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    token_hash VARCHAR(255) NOT NULL,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

### Profile Service Schema
```sql
-- profile_service.sql
CREATE TABLE profiles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID UNIQUE NOT NULL,
    username VARCHAR(50) UNIQUE NOT NULL,
    display_name VARCHAR(100),
    bio TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_profiles_user_id ON profiles(user_id);
```

## Domain Models and Translation Layer

### Auth Service Translation
```go
// internal/domain/user.go
type User struct {
    ID           uuid.UUID
    Email        string
    PasswordHash string
    Status       string
    CreatedAt    time.Time
    UpdatedAt    time.Time
}

// internal/transport/translator/user.go
func UserToProto(u *domain.User) *authv1.User {
    return &authv1.User{
        Id:        u.ID.String(),
        Email:     u.Email,
        Status:    u.Status,
        CreatedAt: timestamppb.New(u.CreatedAt),
        UpdatedAt: timestamppb.New(u.UpdatedAt),
    }
}

func ProtoToUser(p *authv1.User) (*domain.User, error) {
    id, err := uuid.Parse(p.Id)
    if err != nil {
        return nil, fmt.Errorf("invalid user ID: %w", err)
    }
    
    return &domain.User{
        ID:        id,
        Email:     p.Email,
        Status:    p.Status,
        CreatedAt: p.CreatedAt.AsTime(),
        UpdatedAt: p.UpdatedAt.AsTime(),
    }, nil
}
```

### Profile Service Translation
```go
// internal/domain/profile.go
type Profile struct {
    ID          uuid.UUID
    UserID      uuid.UUID
    Username    string
    DisplayName string
    Bio         string
    CreatedAt   time.Time
    UpdatedAt   time.Time
}

// internal/transport/translator/profile.go
func ProfileToProto(p *domain.Profile) *profilev1.Profile {
    return &profilev1.Profile{
        Id:          p.ID.String(),
        UserId:      p.UserID.String(),
        Username:    p.Username,
        DisplayName: p.DisplayName,
        Bio:         p.Bio,
        CreatedAt:   timestamppb.New(p.CreatedAt),
        UpdatedAt:   timestamppb.New(p.UpdatedAt),
    }
}

func ProtoToProfile(p *profilev1.Profile) (*domain.Profile, error) {
    id, err := uuid.Parse(p.Id)
    if err != nil {
        return nil, fmt.Errorf("invalid profile ID: %w", err)
    }
    
    userId, err := uuid.Parse(p.UserId)
    if err != nil {
        return nil, fmt.Errorf("invalid user ID: %w", err)
    }
    
    return &domain.Profile{
        ID:          id,
        UserID:      userId,
        Username:    p.Username,
        DisplayName: p.DisplayName,
        Bio:         p.Bio,
        CreatedAt:   p.CreatedAt.AsTime(),
        UpdatedAt:   p.UpdatedAt.AsTime(),
    }, nil
}
```

## Temporal Workflow Implementation

### Registration Workflow
```go
// internal/temporal/workflows/registration.go
type RegistrationWorkflow struct {
    authClient    authv1.AuthServiceClient
    profileClient profilev1.ProfileServiceClient
}

func (w *RegistrationWorkflow) Execute(ctx workflow.Context, input RegistrationInput) error {
    // Step 1: Create user
    var userID string
    err := workflow.ExecuteActivity(ctx, w.CreateUser, input).Get(ctx, &userID)
    if err != nil {
        return fmt.Errorf("failed to create user: %w", err)
    }

    // Step 2: Create profile
    err = workflow.ExecuteActivity(ctx, w.CreateProfile, CreateProfileInput{
        UserID:      userID,
        Username:    input.Username,
        DisplayName: input.DisplayName,
    }).Get(ctx, nil)
    if err != nil {
        // Compensate: Delete user
        _ = workflow.ExecuteActivity(ctx, w.DeleteUser, userID).Get(ctx, nil)
        return fmt.Errorf("failed to create profile: %w", err)
    }

    return nil
}
```

### Activities
```go
// internal/temporal/activities/user.go
func (a *Activities) CreateUser(ctx context.Context, input RegistrationInput) (string, error) {
    user := &domain.User{
        Email:     input.Email,
        Status:    "pending",
        CreatedAt: time.Now(),
        UpdatedAt: time.Now(),
    }
    
    // Hash password and save user
    user.PasswordHash = a.hashPassword(input.Password)
    
    id, err := a.userRepo.Create(ctx, user)
    if err != nil {
        return "", fmt.Errorf("failed to create user: %w", err)
    }
    
    return id.String(), nil
}

// internal/temporal/activities/profile.go
func (a *Activities) CreateProfile(ctx context.Context, input CreateProfileInput) error {
    userID, err := uuid.Parse(input.UserID)
    if err != nil {
        return fmt.Errorf("invalid user ID: %w", err)
    }
    
    profile := &domain.Profile{
        UserID:      userID,
        Username:    input.Username,
        DisplayName: input.DisplayName,
        CreatedAt:   time.Now(),
        UpdatedAt:   time.Now(),
    }
    
    err = a.profileRepo.Create(ctx, profile)
    if err != nil {
        return fmt.Errorf("failed to create profile: %w", err)
    }
    
    return nil
}
```

# Thought Process

1. Service Boundaries:
   - Separated auth and profile concerns into distinct services
   - Each service has its own database for autonomy
   - Used Temporal for orchestration to maintain consistency

2. Data Model Decisions:
   - Used UUIDs for all IDs to ensure uniqueness across services
   - Included audit timestamps for all records
   - Separated auth tokens into their own table for better management

3. Translation Layer:
   - Created clear separation between domain models and proto messages
   - Implemented proper error handling for ID parsing
   - Maintained type safety throughout the translation process

# Decisions & Actions

- **Decision:** Use separate microservices for auth and profile
  - **Reasoning:** Better separation of concerns, independent scaling
  - **Next Steps:** Create services using template

- **Decision:** Implement Temporal workflow for registration
  - **Reasoning:** Ensures consistency across distributed operations
  - **Next Steps:** Set up Temporal infrastructure

- **Decision:** Use PostgreSQL for service data
  - **Reasoning:** ACID compliance needed for user data
  - **Next Steps:** Deploy databases using CloudNativePG operator

# Integration Path

1. Infrastructure Setup
   - Set up Kubernetes namespace
   - Deploy ScyllaDB for Temporal
   - Deploy PostgreSQL databases

2. Service Implementation
   - Create both services using the template
   - Implement the database schemas
   - Set up the translation layers
   - Implement the Temporal workflow

3. Testing
   - Unit tests for domain logic
   - Integration tests for workflows
   - End-to-end registration flow tests
