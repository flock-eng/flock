---
description: Guidelines for Go unit testing practices
globs: "*_test.go"
---

# Go Unit Testing Practices

<rule>
name: go-unit-testing
description: Defines standards for Go unit testing practices and patterns

filters:
  - type: file_extension
    pattern: "_test\\.go$"
  - type: directory
    pattern: ".*"

actions:
  - type: suggest
    message: |
      When writing Go unit tests:

      1. **Test Structure and Naming**:
         - Place tests in `*_test.go` files adjacent to the code being tested
         - Name test functions as `TestXxx` where Xxx describes the functionality
         - Use descriptive test names that explain the scenario being tested
         
      2. **Table-Driven Tests**:
         ```go
         func TestFunction(t *testing.T) {
             tests := []struct {
                 name     string
                 input    SomeType
                 expected ResultType
                 wantErr  bool
             }{
                 {
                     name:     "happy path",
                     input:    SomeType{},
                     expected: ResultType{},
                     wantErr:  false,
                 },
                 // Add more test cases
             }

             for _, tt := range tests {
                 t.Run(tt.name, func(t *testing.T) {
                     got, err := Function(tt.input)
                     if (err != nil) != tt.wantErr {
                         t.Errorf("unexpected error: %v", err)
                     }
                     if !reflect.DeepEqual(got, tt.expected) {
                         t.Errorf("got %v, want %v", got, tt.expected)
                     }
                 })
             }
         }
         ```

      3. **Dependency Injection and Mocking**:
         - Design interfaces for external dependencies
         - Use dependency injection for better testability
         - Create mocks using `go generate` and `mockgen`
         
         Example interface and mock generation:
         ```go
         //go:generate mockgen -source=repository.go -destination=mock/repository.go
         type Repository interface {
             Get(ctx context.Context, id string) (*Entity, error)
             Save(ctx context.Context, entity *Entity) error
         }
         ```

      4. **Test Isolation and Cleanup**:
         ```go
         func TestWithResources(t *testing.T) {
             // Use t.TempDir() for temporary files
             tmpDir := t.TempDir()
             
             // Register cleanup functions
             t.Cleanup(func() {
                 // Cleanup resources
             })
             
             // Test logic here
         }
         ```

      5. **Parallel Testing**:
         ```go
         func TestParallel(t *testing.T) {
             t.Parallel() // Mark test for parallel execution
             
             tests := []struct{
                 // test cases
             }{}
             
             for _, tt := range tests {
                 tt := tt // Capture range variable
                 t.Run(tt.name, func(t *testing.T) {
                     t.Parallel() // Run subtests in parallel
                     // Test logic
                 })
             }
         }
         ```

      6. **Coverage and Benchmarks**:
         ```bash
         # Run tests with coverage
         go test -cover ./...
         
         # Generate coverage report
         go test -coverprofile=coverage.out ./...
         go tool cover -html=coverage.out
         
         # Run benchmarks
         go test -bench=. -benchmem ./...
         ```

      7. **Best Practices**:
         1. Focus on behavior, not implementation details
         2. One assertion per test when possible
         3. Use subtests for better organization
         4. Keep tests independent and idempotent
         5. Write tests before fixing bugs
         6. Maintain test code with the same standards as production code
         7. Test edge cases and error conditions
         8. Use meaningful test data that represents real scenarios
         9. Keep test output clear and actionable
         10. Regularly run the full test suite

examples:
  - input: |
      func TestRepository_Get(t *testing.T) {
          // Test implementation
      }
    output: "Consider using table-driven tests and t.Run() for better organization. Example:\nt.Run(tc.name, func(t *testing.T) { ... })"
  - input: |
      type Service struct {
          repo Repository
      }
    output: "Good use of dependency injection. Create a mock using:\n//go:generate mockgen -source=service.go -destination=mock/service.go"
  - input: |
      func TestComplexOperation(t *testing.T) {
          result := ComplexOperation()
          if result != expected {
              t.Error("failed")
          }
      }
    output: "Consider breaking this into multiple test cases using table-driven tests and provide more descriptive error messages"

metadata:
  priority: high
  version: 1.0.0
  evolution_history:
    - date: "2024-03-21"
      type: "initial"
      description: "Initial version of Go unit testing practices"
</rule> 